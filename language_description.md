# Wend语言规范

## 一、语言概述

Wend是一种结构化的、简化版的C语言，与C语言的主要区别如下：

1. **强制入口点**：程序的唯一入口必须是`main()`函数。程序所有内容定义在`main()`中，main外没有全局变量、函数等内容。
2. **嵌套函数**：函数内可以定义嵌套函数。所有函数必须定义在`main()`函数内部。允许函数递归和函数重载。
3. **严格顺序**：函数体内部必须按照 **局部变量声明 → 嵌套函数定义 → 可执行语句** 的顺序组织代码（类似于C89）。
4. **变量作用域规则**：每个函数(不包括子函数区域)对应一个作用域，局部变量在当前函数和子函数的作用域中有效。子函数在引用一个变量时，首先在自身作用域中查找，如果找不到再逐层向外查找。同一个作用域中不能定义重名变量,不同的作用域可以有重名变量。
5. **其他限制**：只有int和bool变量，以及int,bool和string三种字面量。系统提供print和println两个函数，能够打印int和string。流程控制仅支持if、else和while循环。

## 二、程序结构

### 2.1 整体结构
每个Wend程序必须且只能有一个`main()`函数作为程序入口：

```c
main() {
    // 1. 局部变量声明（可选）
    int a;
    bool b;
    
    // 2. 嵌套函数定义（可选）
    int add(int x, int y) {
        // 函数内部同样遵循：变量声明 -> 嵌套函数 -> 语句的顺序
        int result;  // 局部变量声明
        result = x + y;  // 语句
        return result;
    }
    
    // 3. 可执行语句（可选）
    a = 10;
    b = true;
    println add(a, 20);
}
```

### 2.2 函数定义语法
函数定义必须严格遵守以下结构：
```
fun_type ID '(' param_list ')' '{' 
var_list 
fun_list 
statement_list 
'}'
```

其中：
- `fun_type`: 函数返回类型（`int`、`bool`或空，空表示void）
- `ID`: 函数名
- `param_list`: 参数列表
- `var_list`: 局部变量声明列表
- `fun_list`: 嵌套函数定义列表
- `statement_list`: 语句列表

**重要约束**：
1. 函数体内部必须按顺序包含：局部变量声明 → 嵌套函数定义 → 可执行语句
2. 不能在语句部分（statement_list）声明局部变量或定义函数
3. 每个部分都可以为空

## 三、数据类型

### 3.1 基本类型
Wend仅支持两种基本数据类型：
- **int**: 整数类型，如 `0`、`-5`、`42`
- **bool**: 布尔类型，仅有两个值 `true` 或 `false`

### 3.2 类型推断
无隐式类型转换，所有类型必须在声明时明确指定。

## 四、词法元素

### 4.1 关键字
| 关键字 | 类别 | 说明 |
|--------|------|------|
| `true`, `false` | 布尔字面量 | 布尔类型的两个取值 |
| `print`, `println` | 输出语句 | 打印输出，println附加换行 |
| `int`, `bool` | 类型声明 | 声明变量或函数的返回类型 |
| `if`, `else` | 条件语句 | 条件分支 |
| `while` | 循环语句 | while循环 |
| `return` | 返回语句 | 从函数返回 |

### 4.2 运算符

#### 算术运算符
| 运算符 | 说明 | 优先级 |
|--------|------|--------|
| `+`, `-` | 加、减（二元） | 低 |
| `*`, `/`, `%` | 乘、除、取模 | 中 |
| `+`, `-` | 正、负（一元） | 高 |

#### 比较运算符
| 运算符 | 说明 |
|--------|------|
| `==`, `!=` | 等于、不等于 |
| `<`, `<=` | 小于、小于等于 |
| `>`, `>=` | 大于、大于等于 |

#### 逻辑运算符
| 运算符 | 说明 |
|--------|------|
| `&&` | 逻辑与 |
| `\|\|` | 逻辑或 |
| `!` | 逻辑非 |

#### 赋值运算符
- `=`：赋值

### 4.3 分隔符
```
()  {}  ;  ,
```
- `()`：函数调用、参数列表、表达式分组
- `{}`：代码块
- `;`：语句结束
- `,`：参数/参数列表分隔

### 4.4 字面量
1. **整数字面量**：十进制数字序列，如 `123`
2. **布尔字面量**：`true` 或 `false`
3. **字符串字面量**：双引号包围的字符序列，如 `"hello"`（支持转义字符）

### 4.5 标识符
- 以字母或下划线开头
- 可包含字母、数字、下划线
- 区分大小写

### 4.6 注释
- 单行注释：以 `//` 开头，直到行尾

## 五、语法规则详解

### 5.1 变量声明
**语法**：
```
TYPE ID;
```
**示例**：
```c
int count;
bool isDone;
```
**规则**：
1. 必须在函数体的变量声明部分（var_list）完成
2. 同一作用域内不能重复定义变量
3. 必须显式指定类型

### 5.2 函数定义
**语法**：
```
[返回类型] 函数名(参数列表) {
    // 1. 局部变量声明
    变量声明1;
    变量声明2;
    
    // 2. 嵌套函数定义
    函数定义1;
    函数定义2;
    
    // 3. 可执行语句
    语句1;
    语句2;
}
```

**示例**：
```c
int max(int a, int b) {
    int result;  // 局部变量声明
    
    // 无嵌套函数定义
    
    if a > b {    // 语句开始
        result = a;
    } else {
        result = b;
    }
    return result;
}
```

### 5.3 函数重载
**规则**：
1. 同一作用域内可以有多个同名函数
2. 必须通过参数列表（参数类型和数量）区分
3. 不支持仅通过返回类型重载

**示例**：
```c
int add(int a, int b) {
    return a + b;
}

int add(int a, int b, int c) {
    return a + b + c;
}
```

### 5.4 参数列表
**语法**：
```
参数列表 = [变量声明] [参数列表 , 变量声明]
```
**示例**：
```c
// 无参数
int getValue() { ... }

// 单个参数
int square(int x) { ... }

// 多个参数
int sum(int a, int b, int c) { ... }
```

### 5.5 语句类型

#### 5.5.1 赋值语句
```c
变量名 = 表达式;
```

#### 5.5.2 函数调用语句
```c
函数名(参数表达式列表);
```

#### 5.5.3 返回语句
```c
return 表达式;  // 有返回值
return;        // 无返回值（void函数）
```

#### 5.5.4 输出语句
```c
print 表达式;    // 不换行输出
println 表达式;  // 换行输出
```

#### 5.5.5 条件语句
```c
if 表达式 {
    // 语句块
} else {
    // 语句块（可选）
}
```

#### 5.5.6 循环语句
```c
while 表达式 {
    // 循环体
}
```

### 5.6 表达式优先级（从低到高）

| 优先级 | 运算符 | 结合性 |
|--------|--------|--------|
| 1 | `||` | 左结合 |
| 2 | `&&` | 左结合 |
| 3 | `==`, `!=`, `<`, `<=`, `>`, `>=` | 左结合 |
| 4 | `+`, `-`（二元） | 左结合 |
| 5 | `*`, `/`, `%` | 左结合 |
| 6 | `!`, `+`, `-`（一元） | 右结合 |
| 7 | 函数调用、字面量、标识符、括号 | N/A |

## 六、语义规则

### 6.1 作用域规则
1. **词法作用域**：变量和函数的作用域从声明处开始，到所在代码块结束
2. **嵌套访问**：内层作用域可以访问外层作用域定义的变量和函数
3. **遮蔽**：内层作用域可以定义与外层同名的变量/函数，此时外层被遮蔽
4. **禁止重复**：同一作用域内不能重复定义变量

### 6.2 类型规则
1. **静态类型**：所有变量和函数都有明确的编译时类型
2. **类型匹配**：
   - 赋值时左右类型必须匹配
   - 函数调用时实参类型必须与形参类型匹配
   - 返回表达式的类型必须与函数返回类型匹配
3. **无隐式转换**：不支持自动类型转换

### 6.3 函数规则
1. **定义顺序**：函数必须在使用前定义（因为解析是按顺序进行的）
2. **递归调用**：支持递归
3. **重载解析**：根据参数类型和数量选择最匹配的函数

## 七、完整示例

### 7.1 计算阶乘
```c
main() {
    int n;
    int result;
    
    // 计算阶乘的函数
    int factorial(int x) {
        int acc;
        int i;
        
        acc = 1;
        i = 1;
        while i <= x {
            acc = acc * i;
            i = i + 1;
        }
        return acc;
    }
    
    n = 5;
    result = factorial(n);
    print "Factorial of ";
    print n;
    print " is ";
    println result;
}
```

### 7.2 函数重载示例
```c
main() {
    int a;
    int b;
    int c;
    
    // 重载函数：两个版本
    int min(int x, int y) {
        if x < y {
            return x;
        }
        return y;
    }
    
    int min(int x, int y, int z) {
        int temp;
        temp = min(x, y);  // 调用两参数版本
        if temp < z {
            return temp;
        }
        return z;
    }
    
    a = 10;
    b = 20;
    c = 15;
    
    println min(a, b);      // 调用两参数版本
    println min(a, b, c);   // 调用三参数版本
}
```

## 八、错误类型

分别通过lexer、parser和analyzer检查一系列错误，包括:

### 8.1 词法错误
1. 非法字符
2. 未闭合的字符串

### 8.2 语法错误
1. 违反函数体结构（变量声明、函数定义、语句的顺序错误）
2. 缺少分号、括号不匹配等
3. 在语句部分声明变量或定义函数

### 8.3 语义错误
1. 变量重复定义
2. 类型不匹配
3. 函数重载冲突（参数列表完全相同）
4. 未定义的变量或函数
5. 参数数量不匹配
6. 返回类型不匹配
7. main函数缺失或重复



